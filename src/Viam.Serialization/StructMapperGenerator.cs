using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Viam.Serialization
{
    [Generator]
    public class StructMapperGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsCandidateClass(s),
                    transform: static (ctx, _) => GetSemanticTargetWithAttribute(ctx))
                .Where(static m => m is not null);

            var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());
            context.RegisterSourceOutput(compilationAndClasses, (spc, source) => Execute(source.Left, source.Right, spc));
        }

        private static void Execute(Compilation compilation, ImmutableArray<INamedTypeSymbol?> classes, SourceProductionContext context)
        {
            foreach (var classSymbol in classes.Distinct(SymbolEqualityComparer.Default))
            {
                if (classSymbol is null)
                    continue;

                if (!AreAllTypesPartial(classSymbol))
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            id: "VIAMGEN002",
                            title: "StructMapper requires partial classes",
                            messageFormat: "Class '{0}' and all containing classes must be marked 'partial' to allow source generation.",
                            category: "StructMapper",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        Location.None,
                        classSymbol.Name));

                    continue; // Skip generation
                }

                var source = GenerateStructMapper((INamedTypeSymbol)classSymbol, context);
                var safeName = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                                            .Replace("global::", "")
                                            .Replace(".", "_");

                context.AddSource($"{safeName}_StructMapper.g.cs", source);
                context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "VIAMGEN001",
                    title: "StructMapperGenerator Info",
                    messageFormat: "Generated mapper for class '{0}'",
                    category: "StructMapper",
                    DiagnosticSeverity.Info,
                    isEnabledByDefault: true),
                Location.None,
                classSymbol.Name));
            }
        }

        private static bool AreAllTypesPartial(ISymbol typeSymbol)
        {
            // Check the main class itself
            if (!typeSymbol.DeclaringSyntaxReferences
                    .Select(syntaxRef => syntaxRef.GetSyntax())
                    .OfType<ClassDeclarationSyntax>()
                    .All(classDecl => classDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword))))
            {
                return false;
            }

            // Check all containing (parent) types
            var current = typeSymbol.ContainingType;
            while (current != null)
            {
                if (!current.DeclaringSyntaxReferences
                        .Select(syntaxRef => syntaxRef.GetSyntax())
                        .OfType<ClassDeclarationSyntax>()
                        .All(classDecl => classDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword))))
                {
                    return false;
                }
                current = current.ContainingType;
            }

            return true;
        }

        private static string GenerateStructMapper(INamedTypeSymbol classSymbol, SourceProductionContext context)
        {
            var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace
                ? null
                : classSymbol.ContainingNamespace.ToDisplayString();

            var className = classSymbol.Name;

            var fullyQualifiedName = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            var sb = new StringBuilder();

            sb.AppendLine($"// <auto-generated />");
            var indent = string.Empty;

            // Walk up containing types
            var containingTypes = new Stack<INamedTypeSymbol>();
            var current = classSymbol.ContainingType;
            while (current != null)
            {
                containingTypes.Push(current);
                current = current.ContainingType;
            }

            if (namespaceName != null)
            {
                sb.AppendLine($"namespace {namespaceName}");
                sb.AppendLine("{");
                indent = "    ";
            }

            // Emit containing classes
            foreach (var containingType in containingTypes)
            {
                sb.AppendLine($"{indent}public partial class {containingType.Name}");
                sb.AppendLine($"{indent}{{");
                indent += "    ";
            }
            sb.AppendLine($"{indent}public partial class {className}");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    public static {fullyQualifiedName} FromStruct(Google.Protobuf.WellKnownTypes.Struct s)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        var result = new {fullyQualifiedName}();");
            indent += "        ";

            foreach (var prop in classSymbol.GetMembers().OfType<IPropertySymbol>())
            {
                var propName = prop.Name;
                Trace(context, $"Processing property '{propName}' of type '{prop.Type}' with original type: '{prop.Type.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}'", prop.Locations.FirstOrDefault());
                if (prop.Type.SpecialType != SpecialType.None)
                {
                    HandleSpecialType(sb, indent, context, prop);
                }
                else if (prop.Type is IArrayTypeSymbol arrayType)
                {
                    Trace(context, propName + " is an array: " + arrayType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                    HandleArray(sb, indent, context, prop, arrayType.ElementType);
                }
                else if (prop.Type is INamedTypeSymbol namedType)
                {
                    Trace(context, $"Type {namedType} implements interfaces: {string.Join("\r\n", namedType.AllInterfaces.Select(x => x.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))}");
                    // Handle dictionary first because it implements IEnumerable
                    if (IsDictionaryish(namedType))
                    {
                        Trace(context, $"Property '{propName}' is a Dictionary: {namedType.ConstructedFrom}");
                        var constructedFrom = namedType.ConstructedFrom.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        if (namedType.TypeArguments[0].SpecialType != SpecialType.System_String)
                        {
                            Trace(context, $"Skipping Dictionary<{namedType.TypeArguments[0]}, {namedType.TypeArguments[1]}> — only Dictionary<string, T> is supported");
                            sb.AppendLine($"{indent}        // Skipping Dictionary<{namedType.TypeArguments[0]}, {namedType.TypeArguments[1]}>: unsupported key type");
                            continue;
                        }

                        Trace(context, $"Property '{propName}' is a generic type: {constructedFrom}");

                        var keyType = namedType.TypeArguments[0];
                        var valueType = namedType.TypeArguments[1];

                        if (keyType.SpecialType == SpecialType.System_String)
                        {
                            HandleDictionary(sb, indent, context, prop, valueType);
                        }
                        else
                        {
                            Trace(context, $"Skipping Dictionary<{keyType}, {valueType}> — only Dictionary<string, T> is supported");
                            sb.AppendLine($"{indent}        // Skipping Dictionary<{keyType}, {valueType}>: unsupported key type");
                        }
                    }
                    else if (IsListIsh(namedType))
                    {
                        Trace(context, propName + " is an enumerable: " + namedType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                        HandleList(sb, indent, context, prop, namedType.TypeArguments[0]);
                    } else
                    {
                        // Assume complex custom POCO type
                        Trace(context, $"Assuming nested POCO for property '{propName}' of type '{prop.Type}'");
                        var fieldName = GetJsonPropertyName(prop);
                        sb.AppendLine($"{indent}if (s.Fields.TryGetValue(\"{fieldName}\", out var {propName}_val) && {propName}_val.KindCase == Google.Protobuf.WellKnownTypes.Value.KindOneofCase.StructValue)");
                        sb.AppendLine($"{indent}{{");
                        sb.AppendLine($"{indent}    result.{propName} = {prop.Type.Name}.FromStruct({propName}_val.StructValue);");
                        sb.AppendLine($"{indent}}}");
                    }
                }
                
                else
                {
                    // Assume complex custom POCO type
                    Trace(context, $"Assuming nested POCO for property '{propName}' of type '{prop.Type}'");
                    var fieldName = GetJsonPropertyName(prop);
                    sb.AppendLine($"{indent}if (s.Fields.TryGetValue(\"{fieldName}\", out var {propName}_val) && {propName}_val.KindCase == Google.Protobuf.WellKnownTypes.Value.KindOneofCase.StructValue)");
                    sb.AppendLine($"{indent}{{");
                    sb.AppendLine($"{indent}    result.{propName} = {prop.Type.Name}.FromStruct({propName}_val.StructValue);");
                    sb.AppendLine($"{indent}}}");
                }
            }


            sb.AppendLine($"{indent}return result;");
            indent = indent.Substring(0, indent.Length - 4);
            sb.AppendLine($"{indent}}}");
            indent = indent.Substring(0, indent.Length - 4);
            sb.AppendLine($"{indent}}}");

            // Close containing classes
            while (containingTypes.Count > 0)
            {
                indent = indent.Substring(0, indent.Length - 4);
                sb.AppendLine($"{indent}}}");
                containingTypes.Pop();
            }

            if (namespaceName != null)
            {
                sb.AppendLine("}");
            }

            return sb.ToString();
        }

        private static bool IsDictionaryish(INamedTypeSymbol namedType)
        {
            return namedType.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Collections.Generic.IDictionary<TKey, TValue>" ||
                namedType.AllInterfaces.Any(i => i.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Collections.Generic.IDictionary<TKey, TValue>");
        }

        private static bool IsListIsh(INamedTypeSymbol namedType)
        {
            return namedType.AllInterfaces.Any(i => i.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Collections.Generic.IEnumerable<T>");
        }

        private static void HandleDictionary(StringBuilder sb, string indent, SourceProductionContext context, IPropertySymbol prop, ITypeSymbol valueType)
        {
            var propName = prop.Name;
            var valueTypeName = valueType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var fieldName = GetJsonPropertyName(prop);
            sb.AppendLine($"{indent}if (s.Fields.TryGetValue(\"{fieldName}\", out var {propName}_val) && {propName}_val.KindCase == Google.Protobuf.WellKnownTypes.Value.KindOneofCase.StructValue)");
            sb.AppendLine($"{indent}{{");
            indent += "    ";
            sb.AppendLine($"{indent}result.{propName} = new global::System.Collections.Generic.Dictionary<string, {valueTypeName}>();");
            sb.AppendLine($"{indent}foreach (var kvp in {propName}_val.StructValue.Fields)");
            sb.AppendLine($"{indent}{{");
            indent += "    ";

            if (valueType.SpecialType == SpecialType.System_String)
            {
                sb.AppendLine($"{indent}result.{propName}[kvp.Key] = kvp.Value.StringValue;");
            }
            else if (valueType.SpecialType == SpecialType.System_Int32 || valueType.SpecialType == SpecialType.System_Int64)
            {
                sb.AppendLine($"{indent}result.{propName}[kvp.Key] = (int)kvp.Value.NumberValue;");
            }
            else if (valueType.SpecialType == SpecialType.System_Single || valueType.SpecialType == SpecialType.System_Double)
            {
                sb.AppendLine($"{indent}result.{propName}[kvp.Key] = kvp.Value.NumberValue;");
            }
            else if (valueType.SpecialType == SpecialType.System_Boolean)
            {
                sb.AppendLine($"{indent}result.{propName}[kvp.Key] = kvp.Value.BoolValue;");
            }
            else
            {
                // Assume it's a nested POCO
                sb.AppendLine($"{indent}if (kvp.Value.KindCase == Google.Protobuf.WellKnownTypes.Value.KindOneofCase.StructValue)");
                sb.AppendLine($"{indent}{{");
                sb.AppendLine($"{indent}    result.{propName}[kvp.Key] = {valueTypeName}.FromStruct(kvp.Value.StructValue);");
                sb.AppendLine($"{indent}}}");
                sb.AppendLine($"{indent}else");
                sb.AppendLine($"{indent}{{");
                sb.AppendLine($"{indent}    result.{propName}[kvp.Key] = default!; // or throw?");
                sb.AppendLine($"{indent}}}");
            }
            indent = indent.Substring(0, indent.Length - 4);
            sb.AppendLine($"{indent}}}");
            indent = indent.Substring(0, indent.Length - 4);
            sb.AppendLine($"{indent}}}");
        }

        private static void HandleSpecialType(StringBuilder sb, string indent, SourceProductionContext context, IPropertySymbol prop)
        {
            var propName = prop.Name;
            var fieldName = GetJsonPropertyName(prop);
            switch (prop.Type.SpecialType)
            {
                case SpecialType.System_String:
                    sb.AppendLine($"{indent}result.{propName} = s.Fields.TryGetValue(\"{fieldName}\", out var {propName}_val) ? {propName}_val.StringValue : \"\";");
                    break;
                case SpecialType.System_Int16:
                case SpecialType.System_Int32:
                case SpecialType.System_Int64:
                    sb.AppendLine($"{indent}result.{propName} = s.Fields.TryGetValue(\"{fieldName}\", out var {propName}_val) ? (int){propName}_val.NumberValue : 0;");
                    break;
                case SpecialType.System_Boolean:
                    sb.AppendLine($"{indent}result.{propName} = s.Fields.TryGetValue(\"{fieldName}\", out var {propName}_val) ? {propName}_val.BoolValue : false;");
                    break;
                case SpecialType.System_Single:
                case SpecialType.System_Double:
                    sb.AppendLine($"{indent}result.{propName} = s.Fields.TryGetValue(\"{fieldName}\", out var {propName}_val) ? {propName}_val.NumberValue : 0;");
                    break;
                case SpecialType.System_Decimal:
                    sb.AppendLine($"{indent}result.{propName} = s.Fields.TryGetValue(\"{fieldName}\", out var {propName}_val) ? (decimal){propName}_val.NumberValue : 0;");
                    break;
                default:
                    sb.AppendLine($"{indent}// Unknown type '{prop.Type}' for property '{propName}'");
                    Trace(context, "Unknown special type: " + prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                    break;
            }
        }

        private static void HandleList(StringBuilder sb, string indent, SourceProductionContext context, IPropertySymbol prop, ITypeSymbol elementType)
        {
            var propName = prop.Name;
            var fieldName = GetJsonPropertyName(prop);
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            sb.AppendLine($"{indent}if (s.Fields.TryGetValue(\"{fieldName}\", out var {propName}_val) && {propName}_val.KindCase == Google.Protobuf.WellKnownTypes.Value.KindOneofCase.ListValue)");
            sb.AppendLine($"{indent}{{");
            indent += "    ";
            sb.AppendLine($"{indent}result.{propName} = new global::System.Collections.Generic.List<{elementTypeName}>();");
            sb.AppendLine($"{indent}foreach (var item in {propName}_val.ListValue.Values)");
            sb.AppendLine($"{indent}{{");
            indent += "    ";

            if (elementType.SpecialType != SpecialType.None)
            {
                switch (elementType.SpecialType)
                {
                    case SpecialType.System_String:
                        sb.AppendLine($"{indent}result.{propName}.Add(item.StringValue);");
                        break;
                    case SpecialType.System_Int16:
                        sb.AppendLine($"{indent}result.{propName}.Add((short)item.NumberValue);");
                        break;
                    case SpecialType.System_Int32:
                        sb.AppendLine($"{indent}result.{propName}.Add((int)item.NumberValue);");
                        break;
                    case SpecialType.System_Int64:
                        sb.AppendLine($"{indent}result.{propName}.Add((long)item.NumberValue);");
                        break;
                    case SpecialType.System_Boolean:
                        sb.AppendLine($"{indent}result.{propName}.Add(item.BoolValue);");
                        break;
                    case SpecialType.System_Single:
                        sb.AppendLine($"{indent}result.{propName}.Add((float)item.NumberValue);");
                        break;
                    case SpecialType.System_Double:
                        sb.AppendLine($"{indent}result.{propName}.Add(item.NumberValue);");
                        break;
                    case SpecialType.System_Decimal:
                        sb.AppendLine($"{indent}result.{propName}.Add((decimal)item.NumberValue);");
                        break;
                    default:
                        sb.AppendLine($"{indent}// Unknown type '{elementType}' for property '{propName}'");
                        Trace(context, "Unknown special type: " + elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                        break;
                }
            }
            else
            {
                Trace(context, $"Assuming nested POCO for property '{propName}' of type '{elementType}'");
                sb.AppendLine($"{indent}result.{propName}.Add({elementType.ToDisplayString()}.FromStruct(item.StructValue));");
            }

            indent = indent.Substring(0, indent.Length - 4);
            sb.AppendLine($"{indent}}}");
            indent = indent.Substring(0, indent.Length - 4);
            sb.AppendLine($"{indent}}}");
        }

        private static void HandleArray(StringBuilder sb, string indent, SourceProductionContext context, IPropertySymbol prop, ITypeSymbol elementType)
        {
            var propName = prop.Name;
            var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var fieldName = GetJsonPropertyName(prop);
            sb.AppendLine($"{indent}if (s.Fields.TryGetValue(\"{fieldName}\", out var {propName}_val) && {propName}_val.KindCase == Google.Protobuf.WellKnownTypes.Value.KindOneofCase.ListValue)");
            sb.AppendLine($"{indent}{{");
            indent += "    ";
            sb.AppendLine($"{indent}var {propName}_arr = new global::System.Collections.Generic.List<{elementTypeName}>();");
            sb.AppendLine($"{indent}foreach (var item in {propName}_val.ListValue.Values)");
            sb.AppendLine($"{indent}{{");
            indent += "    ";

            if (elementType.SpecialType != SpecialType.None)
            {
                switch (elementType.SpecialType)
                {
                    case SpecialType.System_String:
                        sb.AppendLine($"{indent}{propName}_arr.Add(item.StringValue);");
                        break;
                    case SpecialType.System_Int16:
                        sb.AppendLine($"{indent}{propName}_arr.Add((short)item.NumberValue);");
                        break;
                    case SpecialType.System_Int32:
                        sb.AppendLine($"{indent}{propName}_arr.Add((int)item.NumberValue);");
                        break;
                    case SpecialType.System_Int64:
                        sb.AppendLine($"{indent}{propName}_arr.Add((long)item.NumberValue);");
                        break;
                    case SpecialType.System_Boolean:
                        sb.AppendLine($"{indent}{propName}_arr.Add(item.BoolValue);");
                        break;
                    case SpecialType.System_Single:
                        sb.AppendLine($"{indent}{propName}_arr.Add((float)item.NumberValue);");
                        break;
                    case SpecialType.System_Double:
                        sb.AppendLine($"{indent}{propName}_arr.Add(item.NumberValue);");
                        break;
                    case SpecialType.System_Decimal:
                        sb.AppendLine($"{indent}{propName}_arr.Add((decimal)item.NumberValue);");
                        break;
                    default:
                        sb.AppendLine($"{indent}// Unknown type '{elementType}' for property '{propName}'");
                        Trace(context, "Unknown special type: " + elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                        break;
                }
            }
            else
            {
                Trace(context, $"Assuming nested POCO for property '{propName}' of type '{elementType}'");
                sb.AppendLine($"{indent}{propName}_arry.Add({elementType.ToDisplayString()}.FromStruct(item.StructValue));");
            }

            indent = indent.Substring(0, indent.Length - 4);
            sb.AppendLine($"{indent}}}");
            sb.AppendLine($"{indent}result.{propName} = {propName}_arr.ToArray();");
            indent = indent.Substring(0, indent.Length - 4);
            sb.AppendLine($"{indent}}}");
        }

        private static bool IsCandidateClass(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax classDecl
                && classDecl.AttributeLists.Count > 0
                && classDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
        }

        private static INamedTypeSymbol? GetSemanticTargetWithAttribute(GeneratorSyntaxContext context)
        {
            var classDecl = (ClassDeclarationSyntax)context.Node;

            var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
            if (classSymbol == null)
                return null;

            foreach (var attribute in classSymbol.GetAttributes())
            {
                if (attribute.AttributeClass?.ToDisplayString() == "Viam.Core.Serialization.StructMappableAttribute")
                {
                    return classSymbol;
                }
            }

            return null;
        }

        private static string GetJsonPropertyName(IPropertySymbol prop)
        {
            foreach (var attribute in prop.GetAttributes())
            {
                if (attribute.AttributeClass?.ToDisplayString() == "System.Text.Json.Serialization.JsonPropertyNameAttribute" &&
                    attribute.ConstructorArguments.Length == 1)
                {
                    if (attribute.ConstructorArguments[0].Value is string jsonName && !string.IsNullOrWhiteSpace(jsonName))
                    {
                        return jsonName;
                    }
                }
            }
            return prop.Name;
        }

        private static void Trace(SourceProductionContext context, string message, Location? location = null)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "VIAMGENTRACE",
                    title: "StructMapper Trace",
                    messageFormat: "{0}",
                    category: "StructMapper",
                    DiagnosticSeverity.Info,
                    isEnabledByDefault: true),
                location ?? Location.None,
                message));
        }

    }
}
